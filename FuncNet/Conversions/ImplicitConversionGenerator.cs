using System.Collections.Immutable;
using FuncNet.CodeGeneration;
using FuncNet.CodeGeneration.Models;
using FuncNet.Shared.Config;
using Microsoft.CodeAnalysis;

namespace FuncNet.Conversions;

internal sealed class ImplicitConversionGenerator : IIncrementalGenerator
{
	private static readonly ImmutableArray<ImplicitUnionConversionParams> basicConversions =
		(from targetTypeCount in Enumerable.Range(3, UnionMethodConfigConsts.MAX_UNION_SIZE - 2)
			from max in Enumerable.Range(2, targetTypeCount - 2)
			select new ImplicitUnionConversionParams(
				targetTypeCount, Enumerable.Range(0, max).ToImmutableArray()))
		.ToImmutableArray();

	private readonly string typeName;
	private readonly GenerateGenericTypeNameForTIndex typeNameGenerator;
	private readonly Func<ImplicitUnionConversionParams, bool> filterConversionParams;

	public ImplicitConversionGenerator(
		string typeName,
		GenerateGenericTypeNameForTIndex typeNameGenerator,
		Func<ImplicitUnionConversionParams, bool> filterConversionParams)
	{
		this.typeName = typeName;
		this.typeNameGenerator = typeNameGenerator;
		this.filterConversionParams = filterConversionParams;
	}

	public void Initialize(IncrementalGeneratorInitializationContext initializationContext)
	{
		var configProvider = initializationContext.AdditionalTextsProvider
			.Where(file => Path.GetFileName(file.Path) == FuncNetConfig.FILE_NAME)
			.Select((file, cancellationToken) =>
			{
				var text = file.GetText(cancellationToken)?.ToString() ?? "{}";
				var contentDto = SimpleJson.SimpleJson.DeserializeObjectOrDefault(text, new FuncNetConfigFileContentDto());
				return FuncNetConfigFileContent.FromDto(contentDto);
			});

		initializationContext.RegisterSourceOutput(
			configProvider,
			(context, config) =>
			{
				var conversions = GenerateCompatibleConversions(
					config.GenericsRegistrations
						.Select(registration => registration.CommaSeparatedArguments)
						.ToImmutableHashSet());

				foreach (var conversion in conversions)
				{
					context.AddSource(conversion.FileName, conversion.Code);
				}
			});
	}

	private IEnumerable<ImplicitUnionConversion> GenerateCompatibleConversions(IImmutableSet<string> typeGenerics)
	{
		return typeGenerics
			.SelectMany(a => typeGenerics.Select(b => (a, b)))
			.Where(unions => unions.a != unions.b)
			.Select(unions => (bigger: ToTypesArray(unions.a), smaller: ToTypesArray(unions.b)))
			.Where(unions => unions.bigger.Length >= unions.smaller.Length)
			.Where(unions => unions.smaller.All(type => unions.bigger.Contains(type)))
			.Select(ToUnionConversionParams)
			.Concat(basicConversions)
			.Distinct()
			.Where(filterConversionParams)
			.Select(GenerateImplicitConversion);

		static ImmutableArray<string> ToTypesArray(string genericTypes) =>
			genericTypes.Split(',').Select(t => t.Trim()).ToImmutableArray();

		static ImplicitUnionConversionParams ToUnionConversionParams((ImmutableArray<string> bigger, ImmutableArray<string> smaller) types) =>
			new(types.bigger.Length, types.smaller.Select(type => types.bigger.IndexOf(type)).ToImmutableArray());
	}

	private ImplicitUnionConversion GenerateImplicitConversion(ImplicitUnionConversionParams @params)
	{
		var targetTypeParams = string.Join(", ", Enumerable.Range(0, @params.ConversionTargetGenericSize).Select(i => typeNameGenerator(i)));
		var sourceTypeParams = string.Join(", ", @params.ConversionSourceGenericArgsOrder.Select(i => typeNameGenerator(i)));

		return new ImplicitUnionConversion($@"// <auto-generated/>
#nullable enable

namespace FuncNet;

public readonly partial record struct {typeName}<{targetTypeParams}>
{{
    public static implicit operator {typeName}<{targetTypeParams}>({typeName}<{sourceTypeParams}> source) =>
		source.Match<{typeName}<{targetTypeParams}>, {sourceTypeParams}>(
			{string.Join(",\n\t\t\t", @params.ConversionSourceGenericArgsOrder.Select(i => $"t{i} => t{i}"))});
}}", @params, typeName);
	}
}