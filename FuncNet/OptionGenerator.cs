using Microsoft.CodeAnalysis;

namespace FuncNet;

[Generator]
internal sealed class OptionGenerator : ISourceGenerator
{
	public void Initialize(GeneratorInitializationContext context) { }

	public void Execute(GeneratorExecutionContext context)
	{
		context.AddSource("None", @"// <auto-generated/>
namespace FuncNet;

public readonly record struct None
{
	public static None Instance { get; } = new();
}");

		context.AddSource("Option", @"// <auto-generated/>
#nullable enable

using System;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;

namespace FuncNet;

public readonly partial record struct Option<TSome>
{
	public static Option<TSome> None { get; } = new(default, false);

	internal TSome? Value0 { get; init; }
	private bool HasValue { get; }
	internal int Index => HasValue ? 0 : 1;

	private Option(TSome? value, bool hasValue)
	{
		Value0 = value;
		HasValue = hasValue;
	}

	public static Option<TSome> Some(TSome value) => new(value, true);
	public static async Task<Option<TSome>> SomeAsync(Task<TSome> value) => new(await value.ConfigureAwait(false), true);


	public static Option<TSome> FromNullable(TSome? value) => new(value, value is not null);


	public static async Task<Option<TSome>> FromNullableAsync(Task<TSome?> value)
	{
		var v = await value.ConfigureAwait(false);
		return new Option<TSome>(v, v is not null);
	}

	public IEnumerable<TSome> ToEnumerable() => HasValue ? [Value0!] : [];

	public Option<TSomeNew> Bind<TSomeNew>(
		Func<TSome, Option<TSomeNew>> binding)
	{
		var u = this;
		return u.Index switch
		{
			0 => binding(u.Value0!),
			_ => Option<TSomeNew>.None
		};
	}

	public async Task<Option<TSomeNew>> BindAsync<TSomeNew>(
		Func<TSome, Task<Option<TSomeNew>>> binding,
		CancellationToken cancellationToken = default)
	{
		var u = this;
		cancellationToken.ThrowIfCancellationRequested();
		return await (u.Index switch
		{
			0 => binding(u.Value0!),
			_ => Task.FromResult(Option<TSomeNew>.None)
		}).ConfigureAwait(false);
	}

	public Option<TSomeNew> Map<TSomeNew>(
		Func<TSome, TSomeNew> mapping)
	{
		var u = this;
		return u.Index switch
		{
			0 => Option<TSomeNew>.Some(mapping(u.Value0!)),
			_ => Option<TSomeNew>.None
		};
	}

	public async Task<Option<TSomeNew>> MapAsync<TSomeNew>(
		Func<TSome, Task<TSomeNew>> mapping,
		CancellationToken cancellationToken = default)
	{
		var u = this;
		cancellationToken.ThrowIfCancellationRequested();
		return await (u.Index switch
		{
			0 => Option<TSomeNew>.Some(mapping(u.Value0!)),
			_ => Task.FromResult(Option<TSomeNew>.None)
		}).ConfigureAwait(false);
	}

	public Option<TSome> Filter(
		Func<TSome, bool> predicate)
	{
		var u = this;
		if (u.Index == 0 && !predicate(u.Value0!)) return Option<TSome>.None;

		return this;
	}

	public async Task<Option<TSome>> FilterAsync(
		Func<TSome, Task<bool>> predicate,
		CancellationToken cancellationToken = default)
	{
		var u = this;
		cancellationToken.ThrowIfCancellationRequested();
		if (u.Index == 0 && !await predicate(u.Value0!).ConfigureAwait(false)) return Option<TSome>.None;

		return this;
	}

	public Option<TSome> Tap(
		Action<TSome> action)
	{
		var u = this;
		if (u.Index == 0) action(u.Value0!);
		return this;
	}

	public async Task<Option<TSome>> TapAsync(
		Func<TSome, Task> action,
		CancellationToken cancellationToken = default)
	{
		var u = this;
		cancellationToken.ThrowIfCancellationRequested();
		if (u.Index == 0) await action(u.Value0!).ConfigureAwait(false);
		return this;
	}

	public TResult Match<TResult>(
		Func<TSome, TResult> some,
		Func<TResult> none)
	{
		var u = this;
		return u.Index switch
		{
			0 => some(u.Value0!),
			_ => none()
		};
	}

	public async Task<TResult> MatchAsync<TResult>(
		Func<TSome, Task<TResult>> some,
		Func<Task<TResult>> none,
		CancellationToken cancellationToken = default)
	{
		var u = this;
		cancellationToken.ThrowIfCancellationRequested();
		return await (u.Index switch
		{
			0 => some(u.Value0!),
			_ => none()
		}).ConfigureAwait(false);
	}
}");
	}
}