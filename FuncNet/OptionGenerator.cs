using System.Text;
using Microsoft.CodeAnalysis;
using static FuncNet.CodeGeneration.Models.UnionMethodConfigConsts;

namespace FuncNet;

[Generator]
internal sealed class OptionGenerator : ISourceGenerator
{
	public void Initialize(GeneratorInitializationContext context) { }

	public void Execute(GeneratorExecutionContext context)
	{
		// Generate None class
		context.AddSource("None", @"// <auto-generated/>
namespace FuncNet;

public readonly record struct None
{
	public static None Instance { get; } = new();
}");

		var toResultMethods = new StringBuilder();

		for (var errorCount = 1; errorCount < MAX_UNION_SIZE; errorCount++)
		{
			var errorTypeParams = string.Join(", ", Enumerable.Range(0, errorCount).Select(i => $"TError{i}"));
			var resultType = $"Result<TValue, {errorTypeParams}>";
			var errorIfNoneType = errorCount == 1 ? "TError0" : $"Union<{errorTypeParams}>";

			toResultMethods.AppendLine($@"
	public {resultType} ToResult<{errorTypeParams}>(
		Func<{errorIfNoneType}> errorIfNone)
	{{
		return Match(
			some => {resultType}.FromSuccess(some),");

			if (errorCount == 1)
			{
				toResultMethods.AppendLine("			() => errorIfNone());");
			}
			else
			{
				var matchArgs = string.Join(",\n				",
					Enumerable.Range(0, errorCount).Select(i => $"error{i} => error{i}"));

				toResultMethods.AppendLine($"			() => errorIfNone().Match<{resultType}, {errorTypeParams}>(");
				toResultMethods.AppendLine($"				{matchArgs}));");
			}

			toResultMethods.AppendLine("	}");
		}

		context.AddSource("Option", $@"// <auto-generated/>
#nullable enable

using System;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;

namespace FuncNet;

public readonly record struct Option<TValue>
{{
	public static Option<TValue> None {{ get; }} = new(default, false);


	internal TValue? Value0 {{ get; init; }}
	private bool HasValue {{ get; }}
	internal int Index => HasValue ? 0 : 1;

	private Option(TValue? value, bool hasValue)
	{{
		Value0 = value;
		HasValue = hasValue;
	}}

	public static Option<TValue> Some(TValue value) => new(value, true);
	public static async Task<Option<TValue>> Some(Task<TValue> value) => new(await value.ConfigureAwait(false), true);


	public static Option<TValue> FromNullable(TValue? value) => new(value, value is not null);


	public static async Task<Option<TValue>> FromNullable(Task<TValue?> value)
	{{
		var v = await value.ConfigureAwait(false);
		return new Option<TValue>(v, v is not null);
	}}

	public IEnumerable<TValue> ToEnumerable() => HasValue ? [Value0!] : [];

	public Option<TValueNew> Bind<TValueNew>(
		Func<TValue, Option<TValueNew>> binding)
	{{
		var u = this;
		return u.Index switch
		{{
			0 => binding(u.Value0!),
			_ => Option<TValueNew>.None
		}};
	}}

	public async Task<Option<TValueNew>> Bind<TValueNew>(
		Func<TValue, Task<Option<TValueNew>>> binding,
		CancellationToken cancellationToken = default)
	{{
		var u = this;
		cancellationToken.ThrowIfCancellationRequested();
		return await (u.Index switch
		{{
			0 => binding(u.Value0!),
			_ => Task.FromResult(Option<TValueNew>.None)
		}}).ConfigureAwait(false);
	}}

	public Option<TValueNew> Map<TValueNew>(
		Func<TValue, TValueNew> mapping)
	{{
		var u = this;
		return u.Index switch
		{{
			0 => Option<TValueNew>.Some(mapping(u.Value0!)),
			_ => Option<TValueNew>.None
		}};
	}}

	public async Task<Option<TValueNew>> Map<TValueNew>(
		Func<TValue, Task<TValueNew>> mapping,
		CancellationToken cancellationToken = default)
	{{
		var u = this;
		cancellationToken.ThrowIfCancellationRequested();
		return await (u.Index switch
		{{
			0 => Option<TValueNew>.Some(mapping(u.Value0!)),
			_ => Task.FromResult(Option<TValueNew>.None)
		}}).ConfigureAwait(false);
	}}

	public Option<TValue> Filter(
		Func<TValue, bool> predicate)
	{{
		var u = this;
		if (u.Index == 0 && !predicate(u.Value0!)) return Option<TValue>.None;

		return this;
	}}

	public async Task<Option<TValue>> Filter(
		Func<TValue, Task<bool>> predicate,
		CancellationToken cancellationToken = default)
	{{
		var u = this;
		cancellationToken.ThrowIfCancellationRequested();
		if (u.Index == 0 && !await predicate(u.Value0!).ConfigureAwait(false)) return Option<TValue>.None;

		return this;
	}}

	public Option<TValue> Tap(
		Action<TValue> action)
	{{
		var u = this;
		if (u.Index == 0) action(u.Value0!);
		return this;
	}}

	public async Task<Option<TValue>> Tap(
		Func<TValue, Task> action,
		CancellationToken cancellationToken = default)
	{{
		var u = this;
		cancellationToken.ThrowIfCancellationRequested();
		if (u.Index == 0) await action(u.Value0!).ConfigureAwait(false);
		return this;
	}}

	public TResult Match<TResult>(
		Func<TValue, TResult> some,
		Func<TResult> none)
	{{
		var u = this;
		return u.Index switch
		{{
			0 => some(u.Value0!),
			_ => none()
		}};
	}}

	public async Task<TResult> Match<TResult>(
		Func<TValue, Task<TResult>> some,
		Func<Task<TResult>> none,
		CancellationToken cancellationToken = default)
	{{
		var u = this;
		cancellationToken.ThrowIfCancellationRequested();
		return await (u.Index switch
		{{
			0 => some(u.Value0!),
			_ => none()
		}}).ConfigureAwait(false);
	}}
{toResultMethods}
}}");
	}
}