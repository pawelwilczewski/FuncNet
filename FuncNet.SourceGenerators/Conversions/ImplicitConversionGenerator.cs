using System.Collections.Immutable;
using System.Text.RegularExpressions;
using FuncNet.SourceGenerators.CodeGeneration.Models;
using Microsoft.CodeAnalysis;

namespace FuncNet.SourceGenerators.Conversions;

internal sealed class ImplicitConversionGenerator
{
	private static readonly ImmutableArray<ImplicitUnionConversionParams> basicConversions =
		(from targetTypeCount in Enumerable.Range(3, UnionMethodConfigConsts.MAX_UNION_SIZE - 2)
			from max in Enumerable.Range(2, targetTypeCount - 2)
			select new ImplicitUnionConversionParams(
				targetTypeCount, Enumerable.Range(0, max).ToImmutableArray()))
		.ToImmutableArray();

	private readonly string typeName;
	private readonly GenerateGenericTypeNameForTIndex typeNameGenerator;
	private readonly Regex unionTypeRegex;
	private readonly Func<ImplicitUnionConversionParams, bool> filterConversionParams;

	public ImplicitConversionGenerator(
		string typeName,
		GenerateGenericTypeNameForTIndex typeNameGenerator,
		Func<ImplicitUnionConversionParams, bool> filterConversionParams)
	{
		this.typeName = typeName;
		this.typeNameGenerator = typeNameGenerator;
		unionTypeRegex = new Regex($"{typeName}<([^<>]+)>", RegexOptions.Compiled);
		this.filterConversionParams = filterConversionParams;
	}

	public void Initialize(IncrementalGeneratorInitializationContext initializationContext)
	{
		var unionTypeDeclarations = initializationContext.SyntaxProvider
			.CreateSyntaxProvider(
				(syntaxNode, _) => syntaxNode.ToString().Contains($"{typeName}<"),
				(context, _) => context.Node);

		initializationContext.RegisterSourceOutput(
			unionTypeDeclarations.Collect(),
			(context, unionTypes) =>
			{
				var conversions = GenerateCompatibleConversions(ExtractUnionTypes(unionTypes));

				foreach (var conversion in conversions)
				{
					context.AddSource(conversion.FileName, conversion.Code);
				}
			});
	}

	private ImmutableHashSet<string> ExtractUnionTypes(ImmutableArray<SyntaxNode> unionTypeNodes) =>
		unionTypeNodes
			.Select(node => unionTypeRegex.Matches(node.ToString()))
			.SelectMany(matches => matches.Cast<Match>()
				.Where(match => match.Success && match.Groups.Count > 1)
				.Select(match => match.Groups[1].Value.Trim()))
			.ToImmutableHashSet();

	private IEnumerable<ImplicitUnionConversion> GenerateCompatibleConversions(IImmutableSet<string> unionTypeStrings)
	{
		return unionTypeStrings
			.SelectMany(a => unionTypeStrings.Select(b => (a, b)))
			.Where(unions => unions.a != unions.b)
			.Select(unions => (bigger: ToTypesArray(unions.a), smaller: ToTypesArray(unions.b)))
			.Where(unions => unions.bigger.Length >= unions.smaller.Length)
			.Where(unions => unions.smaller.All(type => unions.bigger.Contains(type)))
			.Select(ToUnionConversionParams)
			.Distinct()
			.Except(basicConversions)
			.Where(filterConversionParams)
			.Select(GenerateImplicitConversion);

		static ImmutableArray<string> ToTypesArray(string unionGenericTypes) =>
			unionGenericTypes.Split(',').Select(t => t.Trim()).ToImmutableArray();

		static ImplicitUnionConversionParams ToUnionConversionParams((ImmutableArray<string> bigger, ImmutableArray<string> smaller) unions) =>
			new(unions.bigger.Length, unions.smaller.Select(type => unions.bigger.IndexOf(type)).ToImmutableArray());
	}

	private ImplicitUnionConversion GenerateImplicitConversion(ImplicitUnionConversionParams @params)
	{
		var targetTypeParams = string.Join(", ", Enumerable.Range(0, @params.ConversionTargetGenericSize).Select(i => typeNameGenerator(i)));
		var sourceTypeParams = string.Join(", ", @params.ConversionSourceGenericArgsOrder.Select(i => typeNameGenerator(i)));

		return new ImplicitUnionConversion($@"// <auto-generated/>
#nullable enable

namespace FuncNet;

public readonly partial record struct {typeName}<{targetTypeParams}>
{{
    public static implicit operator {typeName}<{targetTypeParams}>({typeName}<{sourceTypeParams}> source) =>
		source.Match<{typeName}<{targetTypeParams}>, {sourceTypeParams}>(
			{string.Join(",\n\t\t\t", @params.ConversionSourceGenericArgsOrder.Select(i => $"t{i} => t{i}"))});
}}", @params, typeName);
	}
}