using System.Collections.Immutable;
using System.Text.RegularExpressions;
using FuncNet.Generator.CodeGeneration.Models;
using Microsoft.CodeAnalysis;

namespace FuncNet.SourceGenerators.Conversions;

[Generator]
public sealed class UnionConversionGenerator : IIncrementalGenerator
{
	private static readonly Regex unionTypeRegex = new("Union<([^<>]+)>", RegexOptions.Compiled);

	private static readonly ImmutableArray<ImplicitUnionConversionParams> basicConversions =
		(from targetTypeCount in Enumerable.Range(3, UnionMethodAsyncConfigConsts.MAX_UNION_SIZE - 2)
			from max in Enumerable.Range(2, targetTypeCount - 2)
			select new ImplicitUnionConversionParams(
				targetTypeCount, Enumerable.Range(0, max).ToImmutableArray()))
		.ToImmutableArray();

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var unionTypeDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				(s, _) => s.ToString().Contains("Union<"),
				(ctx, _) => ctx.Node.ToString())
			.Where(text => unionTypeRegex.IsMatch(text));

		context.RegisterSourceOutput(
			unionTypeDeclarations.Collect(),
			(spc, unionTypes) =>
			{
				var conversions = GenerateCompatibleConversions(ExtractUnionTypes(unionTypes));

				foreach (var conversion in conversions)
				{
					spc.AddSource(conversion.FileName, conversion.Code);
				}
			});
	}

	private static ISet<string> ExtractUnionTypes(ImmutableArray<string> unionTypeTexts)
	{
		var unionTypes = new HashSet<string>();

		foreach (var text in unionTypeTexts)
		{
			var matches = unionTypeRegex.Matches(text);
			foreach (Match match in matches)
			{
				if (match.Success && match.Groups.Count > 1)
				{
					var typeArgs = match.Groups[1].Value.Trim();
					unionTypes.Add(typeArgs);
				}
			}
		}

		return unionTypes;
	}

	private static IEnumerable<ImplicitUnionConversion> GenerateCompatibleConversions(
		ISet<string> unionTypeStrings)
	{
		IEnumerable<(string a, string b)> unionPairsFromCode =
			from a in unionTypeStrings
			from b in unionTypeStrings
			where a != b
			select (a, b);

		var conversionsFromCode = unionPairsFromCode
			.Select(unions => (bigger: unions.a.Split(',').Select(t => t.Trim()).ToImmutableArray(), smaller: unions.b.Split(',').Select(t => t.Trim()).ToImmutableArray()))
			.Where(unions => unions.bigger.Length >= unions.smaller.Length)
			.Where(unions => unions.smaller.All(type => unions.bigger.Contains(type)))
			.Select(unions => new ImplicitUnionConversionParams(
				unions.bigger.Length,
				unions.smaller.Select(type => unions.bigger.IndexOf(type)).ToImmutableArray()));

		return conversionsFromCode
			.Concat(basicConversions)
			.Distinct()
			.Select(GenerateImplicitConversion);
	}

	private static ImplicitUnionConversion GenerateImplicitConversion(ImplicitUnionConversionParams @params)
	{
		var targetTypeParams = @params.TargetGenericParamsCommaSeparated;
		var sourceTypeParams = @params.SourceGenericParamsCommaSeparated;

		return new ImplicitUnionConversion($@"// <auto-generated/>
#nullable enable

namespace FuncNet;

public readonly partial record struct Union<{targetTypeParams}>
{{
    public static implicit operator Union<{targetTypeParams}>(Union<{sourceTypeParams}> source)
    {{
        return new Union<{targetTypeParams}>(source.Value);
    }}
}}", @params);
	}
}