using System.Collections.Immutable;
using System.Text.RegularExpressions;
using FuncNet.Generator.CodeGeneration.Models;
using Microsoft.CodeAnalysis;

namespace FuncNet.SourceGenerators.Conversions;

[Generator]
public sealed class UnionConversionGenerator : IIncrementalGenerator
{
	private static readonly Regex unionTypeRegex = new("Union<([^<>]+)>", RegexOptions.Compiled);

	private static readonly ImmutableArray<ImplicitUnionConversionParams> basicConversions =
		(from targetTypeCount in Enumerable.Range(3, UnionMethodAsyncConfigConsts.MAX_UNION_SIZE - 2)
			from max in Enumerable.Range(2, targetTypeCount - 2)
			select new ImplicitUnionConversionParams(
				targetTypeCount, Enumerable.Range(0, max).ToImmutableArray()))
		.ToImmutableArray();

	public void Initialize(IncrementalGeneratorInitializationContext initializationContext)
	{
		var unionTypeDeclarations = initializationContext.SyntaxProvider
			.CreateSyntaxProvider(
				(syntaxNode, _) => syntaxNode.ToString().Contains("Union<"),
				(context, _) => context.Node);

		initializationContext.RegisterSourceOutput(
			unionTypeDeclarations.Collect(),
			(context, unionTypes) =>
			{
				var conversions = GenerateCompatibleConversions(ExtractUnionTypes(unionTypes));

				foreach (var conversion in conversions)
				{
					context.AddSource(conversion.FileName, conversion.Code);
				}
			});
	}

	private static ImmutableHashSet<string> ExtractUnionTypes(ImmutableArray<SyntaxNode> unionTypeNodes) =>
		unionTypeNodes
			.Select(node => unionTypeRegex.Matches(node.ToString()))
			.SelectMany(matches => matches.Cast<Match>()
				.Where(match => match.Success && match.Groups.Count > 1)
				.Select(match => match.Groups[1].Value.Trim()))
			.ToImmutableHashSet();

	private static IEnumerable<ImplicitUnionConversion> GenerateCompatibleConversions(IImmutableSet<string> unionTypeStrings)
	{
		return unionTypeStrings
			.SelectMany(a => unionTypeStrings.Select(b => (a, b)))
			.Where(unions => unions.a != unions.b)
			.Select(unions => (bigger: ToTypesArray(unions.a), smaller: ToTypesArray(unions.b)))
			.Where(unions => unions.bigger.Length >= unions.smaller.Length)
			.Where(unions => unions.smaller.All(type => unions.bigger.Contains(type)))
			.Select(ToUnionConversionParams)
			.Concat(basicConversions)
			.Distinct()
			.Select(GenerateImplicitConversion);

		static ImmutableArray<string> ToTypesArray(string unionGenericTypes) =>
			unionGenericTypes.Split(',').Select(t => t.Trim()).ToImmutableArray();

		static ImplicitUnionConversionParams ToUnionConversionParams((ImmutableArray<string> bigger, ImmutableArray<string> smaller) unions) =>
			new(unions.bigger.Length, unions.smaller.Select(type => unions.bigger.IndexOf(type)).ToImmutableArray());
	}

	private static ImplicitUnionConversion GenerateImplicitConversion(ImplicitUnionConversionParams @params)
	{
		var targetTypeParams = @params.TargetGenericParamsCommaSeparated;
		var sourceTypeParams = @params.SourceGenericParamsCommaSeparated;

		return new ImplicitUnionConversion($@"// <auto-generated/>
#nullable enable

namespace FuncNet;

public readonly partial record struct Union<{targetTypeParams}>
{{
    public static implicit operator Union<{targetTypeParams}>(Union<{sourceTypeParams}> source)
    {{
        return new Union<{targetTypeParams}>(source.Value);
    }}
}}", @params);
	}
}