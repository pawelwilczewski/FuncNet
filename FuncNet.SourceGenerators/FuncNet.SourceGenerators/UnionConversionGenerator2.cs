using System.Collections.Immutable;
using System.Text;
using System.Text.RegularExpressions;
using FuncNet.Generator.CodeGeneration.Models;
using Microsoft.CodeAnalysis;

namespace FuncNet.SourceGenerators;

[Generator]
public sealed class UnionConversionGenerator2 : IIncrementalGenerator
{
	private static readonly Regex unionTypeRegex = new("Union<([^<>]+)>", RegexOptions.Compiled);

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var unionTypeDeclarations = context.SyntaxProvider
			.CreateSyntaxProvider(
				(s, _) => s.ToString().Contains("Union<"),
				(ctx, _) => ctx.Node.ToString())
			.Where(text => unionTypeRegex.IsMatch(text));

		context.RegisterSourceOutput(
			unionTypeDeclarations.Collect(),
			(spc, unionTypes) =>
			{
				var extractedTypes = ExtractUnionTypes(unionTypes);
				var conversions = GenerateCompatibleConversions(extractedTypes);

				foreach (var conversion in conversions)
				{
					spc.AddSource(
						$"Union{conversion.targetTypeCount}_From_{conversion.sourceTypes}",
						conversion.code);
				}
			});
	}

	private ISet<string> ExtractUnionTypes(ImmutableArray<string> unionTypeTexts)
	{
		var unionTypes = new HashSet<string>();

		foreach (var text in unionTypeTexts)
		{
			var matches = unionTypeRegex.Matches(text);
			foreach (Match match in matches)
			{
				if (match.Success && match.Groups.Count > 1)
				{
					var typeArgs = match.Groups[1].Value.Trim();
					unionTypes.Add(typeArgs);
				}
			}
		}

		return unionTypes;
	}

	private IEnumerable<(string code, string sourceTypes, int targetTypeCount)> GenerateCompatibleConversions(
		ISet<string> unionTypeStrings)
	{
		IEnumerable<(string a, string b)> unionPairsFromCode =
			from a in unionTypeStrings
			from b in unionTypeStrings
			where a != b
			select (a, b);

		var conversionsFromCode = unionPairsFromCode
			.Select(unions => (bigger: unions.a.Split(',').Select(t => t.Trim()).ToImmutableArray(), smaller: unions.b.Split(',').Select(t => t.Trim()).ToImmutableArray()))
			.Where(unions => unions.bigger.Length >= unions.smaller.Length)
			.Where(unions => unions.smaller.All(type => unions.bigger.Contains(type)))
			.Select(unions => (
				targetTypeCount: unions.bigger.Length,
				sourceGenericArgsOrder: unions.smaller.Select(type => unions.bigger.IndexOf(type)).ToImmutableArray()));

		var basicConversions = Enumerable.Range(3, UnionMethodAsyncConfigConsts.MAX_UNION_SIZE - 2)
			.SelectMany(targetTypeCount => Enumerable.Range(2, targetTypeCount - 2)
				.Select(max => (
					targetTypeCount, sourceGenericArgsOrder: Enumerable.Range(0, max).ToImmutableArray())));

		return conversionsFromCode
			.Concat(basicConversions)
			.DistinctBy(tuple => (tuple.targetTypeCount, string.Join("", tuple.sourceGenericArgsOrder)))
			.Select(tuple => (
				code: GenerateImplicitConversion(tuple.targetTypeCount, tuple.sourceGenericArgsOrder),
				sourceTypes: string.Join("", tuple.sourceGenericArgsOrder),
				tuple.targetTypeCount));
	}

	private string GenerateImplicitConversion(int targetTypeCount, IReadOnlyList<int> sourceGenericArgsOrder)
	{
		var targetTypeParams = string.Join(", ", Enumerable.Range(0, targetTypeCount).Select(i => $"T{i}"));
		var sourceTypeParams = string.Join(", ", sourceGenericArgsOrder.Select(i => $"T{i}"));

		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		sb.AppendLine("using System;");
		sb.AppendLine();
		sb.AppendLine("namespace FuncNet;");
		sb.AppendLine();
		sb.AppendLine("/// <summary>");
		sb.AppendLine($"/// Auto-generated conversion from Union&lt;{sourceTypeParams}&gt; to Union&lt;{targetTypeParams}&gt;");
		sb.AppendLine("/// </summary>");
		sb.AppendLine($"public readonly partial record struct Union<{targetTypeParams}>");
		sb.AppendLine("{");
		sb.AppendLine("    /// <summary>");
		sb.AppendLine($"    /// Implicit conversion from Union&lt;{sourceTypeParams}&gt; to Union&lt;{targetTypeParams}&gt;");
		sb.AppendLine("    /// </summary>");

		sb.AppendLine($"    public static implicit operator Union<{targetTypeParams}>(Union<{sourceTypeParams}> source)");
		sb.AppendLine("    {");
		sb.AppendLine("        // Generated by UnionConversionGenerator");
		sb.AppendLine($"        return new Union<{targetTypeParams}>(source.Value);");
		sb.AppendLine("    }");
		sb.AppendLine("}");

		return sb.ToString();
	}
}

internal static class EnumerableExtensions
{
	// public static int IndexOf<T>(this IEnumerable<T> source, T value)
	// {
	// 	var index = 0;
	// 	foreach (var item in source)
	// 	{
	// 		if (Equals(item, value))
	// 		{
	// 			return index;
	// 		}
	//
	// 		index++;
	// 	}
	//
	// 	return -1;
	// }

	public static IEnumerable<TSource> DistinctBy<TSource, TKey>(
		this IEnumerable<TSource> source,
		Func<TSource, TKey> keySelector,
		IEqualityComparer<TKey>? comparer = null)
	{
		if (source == null) throw new ArgumentNullException(nameof(source));
		if (keySelector == null) throw new ArgumentNullException(nameof(keySelector));

		return _(source, keySelector, comparer);

		static IEnumerable<TSource> _(
			IEnumerable<TSource> source,
			Func<TSource, TKey> keySelector,
			IEqualityComparer<TKey>? comparer)
		{
			var knownKeys = new HashSet<TKey>(comparer);
			foreach (var element in source)
			{
				if (knownKeys.Add(keySelector(element))) yield return element;
			}
		}
	}
}