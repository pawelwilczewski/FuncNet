using System.Text;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;

namespace FuncNet.SourceGenerators;

[Generator]
public sealed class UnionConversionGenerator : IIncrementalGenerator
{
	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		var diagnostics = context.CompilationProvider
			.SelectMany((compilation, _) => compilation.GetDiagnostics())
			.Where(d => d.Id == "CS0029" && d.GetMessage().Contains("Union<"));

		// var conversions =
		// 	context.CompilationProvider
		// 		.SelectMany((c, _) => c.GetDiagnostics())
		// 		.Where(d => d.Id == "CS0029" && d.GetMessage().Contains("Union<"))
		//
		// 		// .Select(d => ExtractTypes(d.GetMessage()))
		// 		.Collect()                               // IEnumerable<(string src,string dst)>
		// 		.SelectMany((x, token) => x.Distinct()); // one item per distinct pair

		// context.RegisterSourceOutput(diagnostics, GenerateMissingConversion);
	}

	private static void GenerateMissingConversion(SourceProductionContext context, Diagnostic diagnostic)
	{
		var message = diagnostic.GetMessage();

#pragma warning disable RS1035
		File.AppendAllText("C:/temp/unionerrors.txt", $"{message}\n");
#pragma warning restore RS1035

		// Extract the source and target Union types from the error message
		var sourceType = ExtractSourceType(message);
		var targetType = ExtractTargetType(message);

		if (string.IsNullOrEmpty(sourceType) || string.IsNullOrEmpty(targetType)) return;

		// Generate the necessary implicit conversion
		var conversion = GenerateImplicitConversion(sourceType, targetType);

		// TODO: remove this stupid duplication but also clean up this file altogether
		var sourceTypes = sourceType.Split(',').Select(t => t.Trim()).ToArray();
		var targetTypes = targetType.Split(',').Select(t => t.Trim()).ToArray();
		var sourceTypeGenericParams = sourceTypes.Select(type => Array.IndexOf(targetTypes, type));

		// Add the generated code
		context.AddSource($"Union{targetType.Count(c => c == ',') + 1}_From_{string.Join("", sourceTypeGenericParams)}", conversion);
	}

	private static string GenerateImplicitConversion(string sourceType, string targetType)
	{
		// Split the type parameters
		var sourceTypes = sourceType.Split(',').Select(t => t.Trim()).ToArray();
		var targetTypes = targetType.Split(',').Select(t => t.Trim()).ToArray();

		// Create the source type and target type strings with generic parameters
		var sourceTypeParams = string.Join(", ", sourceTypes);
		var targetTypeParams = string.Join(", ", targetTypes);

		// For the declaration, we need to use the standard T0, T1, T2... order
		var declarationTypeParams = string.Join(", ", Enumerable.Range(0, targetTypes.Length).Select(i => $"T{i}"));

		var sourceTypeGenericParams = sourceTypes.Select(type => Array.IndexOf(targetTypes, type)).ToArray();
		var sourceTypeGenericParamsCommaSeparated = string.Join(", ", sourceTypeGenericParams.Select(i => $"T{i}"));

		// Define the mapping from source types to target indices
		var typeMapping = new Dictionary<string, int>();
		for (var i = 0; i < sourceTypes.Length; i++)
		{
			// Find the index of this source type in the target types
			var targetIndex = Array.IndexOf(targetTypes, sourceTypes[i]);
			if (targetIndex >= 0)
			{
				typeMapping[sourceTypes[i]] = targetIndex;
			}
			else
			{
				// If not found in target, this is an error case
				typeMapping[sourceTypes[i]] = -1;
			}
		}

		// Generate the partial class and extension method
		var sb = new StringBuilder();
		sb.AppendLine("// <auto-generated/>");
		sb.AppendLine("#nullable enable");
		sb.AppendLine();
		sb.AppendLine("using System;");
		sb.AppendLine();
		sb.AppendLine("namespace FuncNet;");
		sb.AppendLine();
		sb.AppendLine("/// <summary>");
		sb.AppendLine($"/// Auto-generated conversion from Union&lt;{sourceTypeParams}&gt; to Union&lt;{targetTypeParams}&gt;");
		sb.AppendLine("/// </summary>");
		sb.AppendLine($"public readonly partial record struct Union<{declarationTypeParams}>");
		sb.AppendLine("{");
		sb.AppendLine("    /// <summary>");
		sb.AppendLine($"    /// Implicit conversion from Union&lt;{sourceTypeParams}&gt; to Union&lt;{targetTypeParams}&gt;");
		sb.AppendLine("    /// </summary>");

		sb.AppendLine($"    public static implicit operator Union<{declarationTypeParams}>(Union<{sourceTypeGenericParamsCommaSeparated}> source)");
		sb.AppendLine("    {");
		sb.AppendLine("        // Generated because of CS0029 error");

		// sb.AppendLine($"        return source.Match<Union<{declarationTypeParams}>, {sourceTypeGenericParamsCommaSeparated}>(");
		// foreach (var sourceIndex in sourceTypeGenericParams)
		// {
		// 	var isLast = sourceIndex == sourceTypeGenericParams.Last();
		//
		// 	// Use the correct implicit conversion pattern - in FuncNet, values implicitly convert to unions
		// 	sb.AppendLine($"            t{sourceIndex} => Union<{declarationTypeParams}>.FromT{sourceIndex}(t{sourceIndex}){(isLast ? "" : ",")}");
		// }
		// sb.AppendLine("        );");
		// sb.AppendLine("    }");

		sb.AppendLine($"		return new Union<{declarationTypeParams}>(source.Value);\n    }}");

		// sb.AppendLine($"		return new Union<{declarationTypeParams}>(source.Index, {string.Join(", ", sourceTypeGenericParams.Select((sourceIndex, index) => $"value{sourceIndex}: source.Value{index}"))});\n    }}");

		sb.AppendLine("}");

		return sb.ToString();
	}

	private static string ExtractSourceType(string message)
	{
		var match = Regex.Match(message, @"type '(?:FuncNet.)?Union<(.+?)>' to");
		return match.Success ? match.Groups[1].Value : string.Empty;
	}

	private static string ExtractTargetType(string message)
	{
		var match = Regex.Match(message, @"to '(?:FuncNet.)?Union<(.+?)>'");
		return match.Success ? match.Groups[1].Value : string.Empty;
	}
}