using System.Collections.Immutable;
using System.Composition;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeActions;
using Microsoft.CodeAnalysis.CodeFixes;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Formatting;

namespace FuncNet.Analyzers;

[ExportCodeFixProvider(LanguageNames.CSharp, Name = nameof(UnionRegistrationCodeFixProvider))]
[Shared]
public class UnionRegistrationCodeFixProvider : CodeFixProvider
{
	public sealed override ImmutableArray<string> FixableDiagnosticIds =>
		ImmutableArray.Create(UnionRegistrationAnalyzer.DIAGNOSTIC_ID);

	public sealed override FixAllProvider GetFixAllProvider() => WellKnownFixAllProviders.BatchFixer;

	public sealed override Task RegisterCodeFixesAsync(CodeFixContext context)
	{
		var diagnostic = context.Diagnostics.First();
		if (!diagnostic.Properties.TryGetValue("UnionTypeString", out var unionTypeString)
			|| string.IsNullOrEmpty(unionTypeString))
			return Task.CompletedTask;

		context.RegisterCodeFix(
			CodeAction.Create(
				$"Register '{unionTypeString}' in Domain project's {UnionRegistrationAnalyzer.TARGET_FILE_NAME}",
				c => AddOrUpdateUnionRegistrationFileAsync(
					context.Document.Project.Solution, unionTypeString!, c),
				nameof(UnionRegistrationCodeFixProvider) + "_" + unionTypeString),
			diagnostic);

		return Task.CompletedTask;
	}

	private static async Task<Solution> AddOrUpdateUnionRegistrationFileAsync(
		Solution solution,
		string unionTypeStringToAdd,
		CancellationToken cancellationToken)
	{
		var domainProject = solution.Projects.FirstOrDefault(p => p.Name == "Domain");
		if (domainProject == null) return solution;

		const string targetFileName = UnionRegistrationAnalyzer.TARGET_FILE_NAME;
		var newCommentText = $"// {unionTypeStringToAdd}";

		var targetDocument = domainProject.Documents.FirstOrDefault(doc =>
			doc.Name.Equals(targetFileName, StringComparison.OrdinalIgnoreCase));

		CompilationUnitSyntax root;
		DocumentId targetDocumentId;

		if (targetDocument != null)
		{
			targetDocumentId = targetDocument.Id;
			var syntaxTree = await targetDocument.GetSyntaxTreeAsync(cancellationToken).ConfigureAwait(false);
			root = (CompilationUnitSyntax)await syntaxTree!.GetRootAsync(cancellationToken).ConfigureAwait(false);

			if (root.DescendantTrivia()
				.Any(t => t.IsKind(SyntaxKind.SingleLineCommentTrivia)
					&& t.ToString().Trim() == newCommentText.Trim()))
			{
				return solution;
			}
		}
		else
		{
			targetDocumentId = DocumentId.CreateNewId(domainProject.Id, targetFileName);
			const string initialFileContent = @"// <auto-generated/>
// This file lists all Union types used across the solution.
// It is used by the UnionConversionsGenerator to generate implicit conversion methods.
";
			root = SyntaxFactory.ParseCompilationUnit(initialFileContent);
		}

		var funcNetNamespace = root.DescendantNodes()
			.OfType<NamespaceDeclarationSyntax>()
			.FirstOrDefault(n => n.Name.ToString() == "FuncNet");

		var newCommentTriviaWithLineEnding = SyntaxFactory.TriviaList(
			SyntaxFactory.Comment(newCommentText),
			SyntaxFactory.CarriageReturnLineFeed);

		if (funcNetNamespace != null)
		{
			var closeBrace = funcNetNamespace.CloseBraceToken;
			var newLeadingTrivia = closeBrace.LeadingTrivia.AddRange(newCommentTriviaWithLineEnding);
			var newCloseBrace = closeBrace.WithLeadingTrivia(newLeadingTrivia);
			var updatedNamespace = funcNetNamespace.WithCloseBraceToken(newCloseBrace);
			root = root.ReplaceNode(funcNetNamespace, updatedNamespace);
		}
		else
		{
			funcNetNamespace = SyntaxFactory.NamespaceDeclaration(SyntaxFactory.ParseName("FuncNet"))
				.WithOpenBraceToken(SyntaxFactory.Token(SyntaxKind.OpenBraceToken))
				.WithCloseBraceToken(
					SyntaxFactory.Token(SyntaxKind.CloseBraceToken)
						.WithLeadingTrivia(newCommentTriviaWithLineEnding));
			root = root.AddMembers(funcNetNamespace);
		}

		var formattedRoot = Formatter.Format(
			root, solution.Workspace, solution.Workspace.Options, cancellationToken);

		if (targetDocument != null)
		{
			return solution.WithDocumentSyntaxRoot(targetDocumentId, formattedRoot);
		}

		var projectDirectory = Path.GetDirectoryName(domainProject.FilePath)!;
		var newFilePath = Path.Combine(projectDirectory, targetFileName);
		return solution.AddDocument(targetDocumentId, targetFileName, formattedRoot, filePath: newFilePath);
	}
}