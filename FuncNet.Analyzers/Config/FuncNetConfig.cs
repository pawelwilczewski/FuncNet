using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FuncNet.Analyzers.Config;

internal sealed class FuncNetConfig
{
	private readonly ImmutableList<UnionRegistration> unionRegistrations;

	private FuncNetConfig(ImmutableList<UnionRegistration> unionRegistrations) =>
		this.unionRegistrations = unionRegistrations;

	public static FuncNetConfig Empty() => new(ImmutableList<UnionRegistration>.Empty);

	public static async Task<FuncNetConfig> FromDocument(Document document, CancellationToken cancellationToken)
	{
		var syntaxTree = await document.GetSyntaxTreeAsync(cancellationToken);
		(await syntaxTree!.GetRootAsync(cancellationToken))
			.DescendantTrivia()
			.Where(trivia => )

		bool HasSingleComment(string comment) =>
			syntaxTree.GetRoot().DescendantTrivia()
				.Any(t => t.IsKind(SyntaxKind.SingleLineCommentTrivia)
					&& t.ToString().Contains(comment.Trim()));
	}

	public FuncNetConfig WithUnionRegistration(UnionRegistration registration) =>
		new(unionRegistrations.Add(registration));

	public bool HasRegistration(UnionRegistration registration) =>
		unionRegistrations.Contains(registration);

	public CompilationUnitSyntax ToSyntaxRoot()
	{
		var fileContent = $@"// <auto-generated/>
// This file lists all Union types used across the solution.
// It is used by the UnionConversionsGenerator to generate implicit conversion methods.

internal static class FuncNetConfig
{{
	{string.Join("\n\t", unionRegistrations.Select(registration => $"// {registration.TypeName}"))}
}}";
		return SyntaxFactory.ParseCompilationUnit(fileContent);
	}
}