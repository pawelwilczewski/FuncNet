using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace FuncNet.Analyzers.Config;

internal sealed record class FuncNetConfigFile
{
	public const string FILE_NAME = "FuncNetConfig.cs";

	public Document Document { get; init; }

	public CompilationUnitSyntax SyntaxRoot
	{
		get
		{
			if (!Document.TryGetSyntaxTree(out var syntaxTree))
			{
				throw new Exception("Unreachable: should always have syntax tree cached");
			}

			return (CompilationUnitSyntax)syntaxTree!.GetRoot();
		}
	}

	private FuncNetConfigFile(Document document) =>
		Document = document;

	public bool HasSingleComment(string comment) =>
		SyntaxRoot.DescendantTrivia()
			.Any(t => t.IsKind(SyntaxKind.SingleLineCommentTrivia)
				&& t.ToString().Contains(comment.Trim()));

	public static async Task<FuncNetConfigFile> GetOrCreate(
		Project rootProject,
		string targetFileName,
		CancellationToken cancellationToken)
	{
		var document = rootProject.Documents.FirstOrDefault(doc =>
			doc.Name.Equals(targetFileName, StringComparison.OrdinalIgnoreCase));

		if (document is null)
		{
			const string initialFileContent = @"// <auto-generated/>
// This file lists all Union types used across the solution.
// It is used by the UnionConversionsGenerator to generate implicit conversion methods.
";
			var root = SyntaxFactory.ParseCompilationUnit(initialFileContent);

			var projectDirectory = Path.GetDirectoryName(rootProject.FilePath)!;
			var newFilePath = Path.Combine(projectDirectory, FILE_NAME);
			document = rootProject.AddDocument(FILE_NAME, root, filePath: newFilePath);
		}

		// ensure syntax tree is cached
		await document.GetSyntaxTreeAsync(cancellationToken).ConfigureAwait(false);

		return new FuncNetConfigFile(document);
	}

	public FuncNetConfigFile WithSyntaxRoot(Func<CompilationUnitSyntax, CompilationUnitSyntax> mapRoot) =>
		this with
		{
			Document = Document.WithSyntaxRoot(mapRoot(SyntaxRoot))
		};
}